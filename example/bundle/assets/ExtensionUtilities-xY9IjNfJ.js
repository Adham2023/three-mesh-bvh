import{M as B,j as I,K as x,aO as S,Y as _,V as R,n as V}from"./ExtendedTriangle-CtXgmvQ9.js";import{M as y}from"./MeshBVH-gvUqwvsz.js";function b(e,t,r){return e===null?null:(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(r.ray.origin),e.object=t,e)}const W=parseInt(S)>=166,g=new _,p=new R,w=new V,A=B.prototype.raycast,F=I.prototype.raycast,T=new R,s=new B,m=[];function C(e,t){this.isBatchedMesh?v.call(this,e,t):O.call(this,e,t)}function v(e,t){if(this.boundsTrees){const r=this.boundsTrees,o=this._drawInfo,n=this._drawRanges,i=this.matrixWorld;s.material=this.material,s.geometry=this.geometry;const l=s.geometry.boundsTree,h=s.geometry.drawRange;s.geometry.boundingSphere===null&&(s.geometry.boundingSphere=new x);for(let a=0,u=o.length;a<u;a++){if(!this.getVisibleAt(a))continue;const d=o[a].geometryIndex;if(s.geometry.boundsTree=r[d],this.getMatrixAt(a,s.matrixWorld).premultiply(i),!s.geometry.boundsTree){this.getBoundingBoxAt(d,s.geometry.boundingBox),this.getBoundingSphereAt(d,s.geometry.boundingSphere);const c=n[d];s.geometry.setDrawRange(c.start,c.count)}s.raycast(e,m);for(let c=0,M=m.length;c<M;c++){const f=m[c];f.object=this,f.batchId=a,t.push(f)}m.length=0}s.geometry.boundsTree=l,s.geometry.drawRange=h,s.material=null,s.geometry=null}else F.call(this,e,t)}function O(e,t){if(this.geometry.boundsTree){if(this.material===void 0)return;w.copy(this.matrixWorld).invert(),g.copy(e.ray).applyMatrix4(w),T.setFromMatrixScale(this.matrixWorld),p.copy(g.direction).multiply(T);const r=p.length(),o=e.near/r,n=e.far/r,i=this.geometry.boundsTree;if(e.firstHitOnly===!0){const l=b(i.raycastFirst(g,this.material,o,n),this,e);l&&t.push(l)}else{const l=i.raycast(g,this.material,o,n);for(let h=0,a=l.length;h<a;h++){const u=b(l[h],this,e);u&&t.push(u)}}}else A.call(this,e,t)}function D(e={}){return this.boundsTree=new y(this,e),this.boundsTree}function H(){this.boundsTree=null}function N(e=-1,t={}){if(!W)throw new Error("BatchedMesh: Three r166+ is required to compute bounds trees.");t.indirect&&console.warn('"Indirect" is set to false because it is not supported for BatchedMesh.'),t={...t,indirect:!1,range:null};const r=this._drawRanges,o=this._geometryCount;this.boundsTrees||(this.boundsTrees=new Array(o).fill(null));const n=this.boundsTrees;for(;n.length<o;)n.push(null);if(e<0){for(let i=0;i<o;i++)t.range=r[i],n[i]=new y(this.geometry,t);return n}else return e<r.length&&(t.range=r[e],n[e]=new y(this.geometry,t)),n[e]||null}function q(e=-1){e<0?this.boundsTrees.fill(null):e<this.boundsTree.length&&(this.boundsTrees[e]=null)}export{C as a,N as b,D as c,H as d,q as e};
